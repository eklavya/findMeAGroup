    akka {
    actor {
    provider = "akka.cluster.ClusterActorRefProvider"
    }
    remote {
    log-remote-lifecycle-events = off
    netty.tcp {
    hostname = "127.0.0.1"
    port = 0
    maximum-frame-size = 900000000b
    }
    }
     
    cluster {
    seed-nodes = ["akka.tcp://ClusterSystem@127.0.0.1:2551"]
     
    auto-down = on
    }
    }

minimum-processors = 1

processors.ask.timeout = 10000

result.accumulation.timeout = 11500

processor.parFac = 4

graphInput = "/home/eklavya/github_data"

coeff = 1.1






    ######################################
    # Akka Cluster Reference Config File #
    ######################################

    # This is the reference config file that contains all the default settings.
    # Make your edits/overrides in your application.conf.

    akka {

    cluster {
    # Initial contact points of the cluster.
    # The nodes to join automatically at startup.
    # Comma separated full URIs defined by a string on the form of
    # "akka://system@hostname:port"
    # Leave as empty if the node is supposed to be joined manually.

    # how long to wait for one of the seed nodes to reply to initial join request
    seed-node-timeout = 10s

    # If a join request fails it will be retried after this period.
    # Disable join retry by specifying "off".
    retry-unsuccessful-join-after = 10s

    # Should the 'leader' in the cluster be allowed to automatically mark
    # unreachable nodes as DOWN?
    # Using auto-down implies that two separate clusters will automatically be
    # formed in case of network partition.

    # The roles of this member. List of strings, e.g. roles = ["A", "B"].
    # The roles are part of the membership information and can be used by
    # routers or other services to distribute work to certain member types,
    # e.g. front-end and back-end nodes.
    roles = []

    role {
    # Minimum required number of members of a certain role before the leader
    # changes member status of 'Joining' members to 'Up'. Typically used together
    # with 'Cluster.registerOnMemberUp' to defer some action, such as starting
    # actors, until the cluster has reached a certain size.
    # E.g. to require 2 nodes with role 'frontend' and 3 nodes with role 'backend':
    # frontend.min-nr-of-members = 2
    # backend.min-nr-of-members = 3
    #<role-name>.min-nr-of-members = 1
    }

    # Minimum required number of members before the leader changes member status
    # of 'Joining' members to 'Up'. Typically used together with
    # 'Cluster.registerOnMemberUp' to defer some action, such as starting actors,
    # until the cluster has reached a certain size.
    min-nr-of-members = 1

    # Enable/disable info level logging of cluster events
    log-info = on

    # Enable or disable JMX MBeans for management of the cluster
    jmx.enabled = on

    # how long should the node wait before starting the periodic tasks
    # maintenance tasks?
    periodic-tasks-initial-delay = 1s

    # how often should the node send out gossip information?
    gossip-interval = 60s

    # how often should the leader perform maintenance tasks?
    leader-actions-interval = 20s

    # how often should the node move nodes, marked as unreachable by the failure
    # detector, out of the membership ring?
    unreachable-nodes-reaper-interval = 60s

    # How often the current internal stats should be published.
    # A value of 0s can be used to always publish the stats, when it happens.
    # Disable with "off".
    publish-stats-interval = off

    # The id of the dispatcher to use for cluster actors. If not specified
    # default dispatcher is used.
    # If specified you need to define the settings of the actual dispatcher.
    use-dispatcher = ""

    # Gossip to random node with newer or older state information, if any with
    # this probability. Otherwise Gossip to any random live node.
    # Probability value is between 0.0 and 1.0. 0.0 means never, 1.0 means always.
    gossip-different-view-probability = 0.8

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the cluster subsystem to detect unreachable
    # members.
    failure-detector {

    # FQCN of the failure detector implementation.
    # It must implement akka.remote.FailureDetector and have
    # a public constructor with a com.typesafe.config.Config and
    # akka.actor.EventStream parameter.
    implementation-class = "akka.remote.PhiAccrualFailureDetector"

    # How often keep-alive heartbeat messages should be sent to each connection.
    heartbeat-interval = 20 s

    # Defines the failure detector threshold.
    # A low threshold is prone to generate many wrong suspicions but ensures
    # a quick detection in the event of a real crash. Conversely, a high
    # threshold generates fewer mistakes but needs more time to detect
    # actual crashes.
    threshold = 8.0

    # Number of the samples of inter-heartbeat arrival times to adaptively
    # calculate the failure timeout for connections.
    max-sample-size = 1000

    # Minimum standard deviation to use for the normal distribution in
    # AccrualFailureDetector. Too low standard deviation might result in
    # too much sensitivity for sudden, but normal, deviations in heartbeat
    # inter arrival times.
    min-std-deviation = 600 ms

    # Number of potentially lost/delayed heartbeats that will be
    # accepted before considering it to be an anomaly.
    # This margin is important to be able to survive sudden, occasional,
    # pauses in heartbeat arrivals, due to for example garbage collect or
    # network drop.
    acceptable-heartbeat-pause = 30 s

    # Number of member nodes that each member will send heartbeat messages to,
    # i.e. each node will be monitored by this number of other nodes.
    monitored-by-nr-of-members = 2

    # When a node stops sending heartbeats to another node it will end that
    # with this number of EndHeartbeat messages, which will remove the
    # monitoring from the failure detector.
    nr-of-end-heartbeats = 8

    # When no expected heartbeat message has been received an explicit
    # heartbeat request is sent to the node that should emit heartbeats.
    heartbeat-request {
    # Grace period until an explicit heartbeat request is sent
    grace-period = 30 s

    # After the heartbeat request has been sent the first failure detection
    # will start after this period, even though no heartbeat mesage has
    # been received.
    expected-response-after = 10 s

    # Cleanup of obsolete heartbeat requests
    time-to-live = 60 s
    }
    }

    metrics {
    # Enable or disable metrics collector for load-balancing nodes.
    enabled = on

    # FQCN of the metrics collector implementation.
    # It must implement akka.cluster.MetricsCollector and
    # have public constructor with akka.actor.ActorSystem parameter.
    # The default SigarMetricsCollector uses JMX and Hyperic SIGAR, if SIGAR
    # is on the classpath, otherwise only JMX.
    collector-class = "akka.cluster.SigarMetricsCollector"

    # How often metrics are sampled on a node.
    # Shorter interval will collect the metrics more often.
    collect-interval = 20s

    # How often a node publishes metrics information.
    gossip-interval = 20s

    # How quickly the exponential weighting of past data is decayed compared to
    # new data. Set lower to increase the bias toward newer values.
    # The relevance of each data sample is halved for every passing half-life
    # duration, i.e. after 4 times the half-life, a data sample’s relevance is
    # reduced to 6% of its original relevance. The initial relevance of a data
    # sample is given by 1 – 0.5 ^ (collect-interval / half-life).
    # See http://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average
    moving-average-half-life = 12s
    }

    # If the tick-duration of the default scheduler is longer than the
    # tick-duration configured here a dedicated scheduler will be used for
    # periodic tasks of the cluster, otherwise the default scheduler is used.
    # See akka.scheduler settings for more details.
    scheduler {
    tick-duration = 33ms
    ticks-per-wheel = 512
    }

    }

    # Default configuration for routers
    actor.deployment.default {
    # MetricsSelector to use
    # - available: "mix", "heap", "cpu", "load"
    # - or: Fully qualified class name of the MetricsSelector class.
    # The class must extend akka.cluster.routing.MetricsSelector
    # and have a public constructor with com.typesafe.config.Config
    # parameter.
    # - default is "mix"
    metrics-selector = mix
    }
    actor.deployment.default.cluster {
    # enable cluster aware router that deploys to nodes in the cluster
    enabled = off

    # Maximum number of routees that will be deployed on each cluster
    # member node.
    # Note that nr-of-instances defines total number of routees, but
    # number of routees per node will not be exceeded, i.e. if you
    # define nr-of-instances = 50 and max-nr-of-instances-per-node = 2
    # it will deploy 2 routees per new member in the cluster, up to
    # 25 members.
    max-nr-of-instances-per-node = 1

    # Defines if routees are allowed to be located on the same node as
    # the head router actor, or only on remote nodes.
    # Useful for master-worker scenario where all routees are remote.
    allow-local-routees = on

    # Actor path of the routees to lookup with actorFor on the member
    # nodes in the cluster. E.g. "/user/myservice". If this isn't defined
    # the routees will be deployed instead of looked up.
    # max-nr-of-instances-per-node should not be configured (default value is 1)
    # when routees-path is defined.
    routees-path = ""

    # Use members with specified role, or all members if undefined or empty.
    use-role = ""

    }

    # Protobuf serializer for cluster messages
    actor {
    serializers {
    akka-cluster = "akka.cluster.protobuf.ClusterMessageSerializer"
    }

    serialization-bindings {
    "akka.cluster.ClusterMessage" = akka-cluster
    }
    }

    }



    #####################################
    # Akka Remote Reference Config File #
    #####################################

    # This is the reference config file that contains all the default settings.
    # Make your edits/overrides in your application.conf.

    # comments about akka.actor settings left out where they are already in akka-
    # actor.jar, because otherwise they would be repeated in config rendering.

    akka {

    remote {

    ### General settings

    # Timeout after which the startup of the remoting subsystem is considered
    # to be failed. Increase this value if your transport drivers (see the
    # enabled-transports section) need longer time to be loaded.
    startup-timeout = 30 s

    # Timout after which the graceful shutdown of the remoting subsystem is
    # considered to be failed. After the timeout the remoting system is
    # forcefully shut down. Increase this value if your transport drivers
    # (see the enabled-transports section) need longer time to stop properly.
    shutdown-timeout = 30 s

    # Before shutting down the drivers, the remoting subsystem attempts to flush
    # all pending writes. This setting controls the maximum time the remoting is
    # willing to wait before moving on to shut down the drivers.
    flush-wait-on-shutdown = 10 s

    ### Failure detection and recovery

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used by the remoting subsystem to detect failed
    # connections.
    transport-failure-detector {

    # FQCN of the failure detector implementation.
    # It must implement akka.remote.FailureDetector and have
    # a public constructor with a com.typesafe.config.Config and
    # akka.actor.EventStream parameter.
    implementation-class = "akka.remote.PhiAccrualFailureDetector"

    # How often keep-alive heartbeat messages should be sent to each connection.
    heartbeat-interval = 30 s

    # Defines the failure detector threshold.
    # A low threshold is prone to generate many wrong suspicions but ensures
    # a quick detection in the event of a real crash. Conversely, a high
    # threshold generates fewer mistakes but needs more time to detect
    # actual crashes.
    threshold = 7.0

    # Number of the samples of inter-heartbeat arrival times to adaptively
    # calculate the failure timeout for connections.
    max-sample-size = 100

    # Minimum standard deviation to use for the normal distribution in
    # AccrualFailureDetector. Too low standard deviation might result in
    # too much sensitivity for sudden, but normal, deviations in heartbeat
    # inter arrival times.
    min-std-deviation = 100 ms

    # Number of potentially lost/delayed heartbeats that will be
    # accepted before considering it to be an anomaly.
    # This margin is important to be able to survive sudden, occasional,
    # pauses in heartbeat arrivals, due to for example garbage collect or
    # network drop.
    acceptable-heartbeat-pause = 30 s
    }

    # Settings for the Phi accrual failure detector (http://ddg.jaist.ac.jp/pub/HDY+04.pdf
    # [Hayashibara et al]) used for remote death watch.
    watch-failure-detector {

    # FQCN of the failure detector implementation.
    # It must implement akka.remote.FailureDetector and have
    # a public constructor with a com.typesafe.config.Config and
    # akka.actor.EventStream parameter.
    implementation-class = "akka.remote.PhiAccrualFailureDetector"

    # How often keep-alive heartbeat messages should be sent to each connection.
    heartbeat-interval = 30 s

    # Defines the failure detector threshold.
    # A low threshold is prone to generate many wrong suspicions but ensures
    # a quick detection in the event of a real crash. Conversely, a high
    # threshold generates fewer mistakes but needs more time to detect
    # actual crashes.
    threshold = 20.0

    # Number of the samples of inter-heartbeat arrival times to adaptively
    # calculate the failure timeout for connections.
    max-sample-size = 200

    # Minimum standard deviation to use for the normal distribution in
    # AccrualFailureDetector. Too low standard deviation might result in
    # too much sensitivity for sudden, but normal, deviations in heartbeat
    # inter arrival times.
    min-std-deviation = 100 ms

    # Number of potentially lost/delayed heartbeats that will be
    # accepted before considering it to be an anomaly.
    # This margin is important to be able to survive sudden, occasional,
    # pauses in heartbeat arrivals, due to for example garbage collect or
    # network drop.
    acceptable-heartbeat-pause = 40 s


    # How often to check for nodes marked as unreachable by the failure
    # detector
    unreachable-nodes-reaper-interval = 60s

    # After the heartbeat request has been sent the first failure detection
    # will start after this period, even though no heartbeat mesage has
    # been received.
    expected-response-after = 40 s

    }

    # After failed to establish an outbound connection, the remoting will mark the
    # address as failed. This configuration option controls how much time should
    # be elapsed before reattempting a new connection. While the address is
    # gated, all messages sent to the address are delivered to dead-letters.
    # If this setting is 0, the remoting will always immediately reattempt
    # to establish a failed outbound connection and will buffer writes until
    # it succeeds.
    retry-gate-closed-for = 2 s

    # If the retry gate function is disabled (see retry-gate-closed-for) the
    # remoting subsystem will always attempt to reestablish failed outbound
    # connections. The settings below together control the maximum number of
    # reattempts in a given time window. The number of reattempts during
    # a window of "retry-window" will be maximum "maximum-retries-in-window".
    retry-window = 60 s
    maximum-retries-in-window = 3

    # The length of time to gate an address whose name lookup has failed
    # or has explicitly signalled that it will not accept connections
    # (remote system is shutting down or the requesting system is quarantined).
    # No connection attempts will be made to an address while it remains
    # gated. Any messages sent to a gated address will be directed to dead
    # letters instead. Name lookups are costly, and the time to recovery
    # is typically large, therefore this setting should be a value in the
    # order of seconds or minutes.
    gate-invalid-addresses-for = 60 s

    # This settings controls how long a system will be quarantined after
    # catastrophic communication failures that result in the loss of system
    # messages. Quarantining prevents communication with the remote system
    # of a given UID. This function can be disabled by setting the value
    # to "off".
    quarantine-systems-for = 60s

    # This setting defines the maximum number of unacknowledged system messages
    # allowed for a remote system. If this limit is reached the remote system is
    # declared to be dead and its UID marked as tainted.
    system-message-buffer-size = 1000

    # This setting defines the maximum idle time after an individual
    # acknowledgement for system messages is sent. System message delivery
    # is guaranteed by explicit acknowledgement messages. These acks are
    # piggybacked on ordinary traffic messages. If no traffic is detected
    # during the time period configured here, the remoting will send out
    # an individual ack.
    system-message-ack-piggyback-timeout = 1 s

    # This setting defines the time after messages that have not been
    # explicitly acknowledged or negatively acknowledged are resent.
    # Messages that were negatively acknowledged are always immediately
    # resent.
    resend-interval = 1 s


    ### Default configuration for the Netty based transport drivers

    netty.tcp {
    # The class given here must implement the akka.remote.transport.Transport
    # interface and offer a public constructor which takes two arguments:
    # 1) akka.actor.ExtendedActorSystem
    # 2) com.typesafe.config.Config
    transport-class = "akka.remote.transport.netty.NettyTransport"

    # Transport drivers can be augmented with adapters by adding their
    # name to the applied-adapters list. The last adapter in the
    # list is the adapter immediately above the driver, while
    # the first one is the top of the stack below the standard
    # Akka protocol
    applied-adapters = []

    transport-protocol = tcp

    # The default remote server port clients should connect to.
    # Default is 2552 (AKKA), use 0 if you want a random available port
    # This port needs to be unique for each actor system on the same machine.

    # The hostname or ip to bind the remoting to,
    # InetAddress.getLocalHost.getHostAddress is used if empty

    # Sets the connectTimeoutMillis of all outbound connections,
    # i.e. how long a connect may take until it is timed out
    connection-timeout = 60 s

    # If set to "<id.of.dispatcher>" then the specified dispatcher
    # will be used to accept inbound connections, and perform IO. If "" then
    # dedicated threads will be used.
    # Please note that the Netty driver only uses this configuration and does
    # not read the "akka.remote.use-dispatcher" entry. Instead it has to be
    # configured manually to point to the same dispatcher if needed.
    use-dispatcher-for-io = ""

    # Sets the high water mark for the in and outbound sockets,
    # set to 0b for platform default
    write-buffer-high-water-mark = 0b

    # Sets the low water mark for the in and outbound sockets,
    # set to 0b for platform default
    write-buffer-low-water-mark = 0b

    # Sets the send buffer size of the Sockets,
    # set to 0b for platform default
    send-buffer-size = 256000b

    # Sets the receive buffer size of the Sockets,
    # set to 0b for platform default
    receive-buffer-size = 256000b

    # Maximum message size the transport will accept, but at least
    # 32000 bytes.
    # Please note that UDP does not support arbitrary large datagrams,
    # so this setting has to be chosen carefully when using UDP.
    # Both send-buffer-size and receive-buffer-size settings has to
    # be adjusted to be able to buffer messages of maximum size.
    maximum-frame-size = 90000000b

    # Sets the size of the connection backlog
    backlog = 4096

    # Enables the TCP_NODELAY flag, i.e. disables Nagle’s algorithm
    tcp-nodelay = on

    # Enables TCP Keepalive, subject to the O/S kernel’s configuration
    tcp-keepalive = on

    # Enables SO_REUSEADDR, which determines when an ActorSystem can open
    # the specified listen port (the meaning differs between *nix and Windows)
    # Valid values are "on", "off" and "off-for-windows"
    # due to the following Windows bug: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4476378
    # "off-for-windows" of course means that it's "on" for all other platforms
    tcp-reuse-addr = off-for-windows

    # Used to configure the number of I/O worker threads on server sockets
    server-socket-worker-pool {
    # Min number of threads to cap factor-based number to
    pool-size-min = 2

    # The pool size factor is used to determine thread pool size
    # using the following formula: ceil(available processors * factor).
    # Resulting size is then bounded by the pool-size-min and
    # pool-size-max values.
    pool-size-factor = 1.0

    # Max number of threads to cap factor-based number to
    pool-size-max = 2
    }

    # Used to configure the number of I/O worker threads on client sockets
    client-socket-worker-pool {
    # Min number of threads to cap factor-based number to
    pool-size-min = 2

    # The pool size factor is used to determine thread pool size
    # using the following formula: ceil(available processors * factor).
    # Resulting size is then bounded by the pool-size-min and
    # pool-size-max values.
    pool-size-factor = 1.0

    # Max number of threads to cap factor-based number to
    pool-size-max = 2
    }


    }

    netty.udp = ${akka.remote.netty.tcp}
    netty.udp {
    transport-protocol = udp
    }

    netty.ssl = ${akka.remote.netty.tcp}
    netty.ssl = {
    # Enable SSL/TLS encryption.
    # This must be enabled on both the client and server to work.
    enable-ssl = true

    security {
    # This is the Java Key Store used by the server connection
    key-store = "keystore"

    # This password is used for decrypting the key store
    key-store-password = "changeme"

    # This password is used for decrypting the key
    key-password = "changeme"

    # This is the Java Key Store used by the client connection
    trust-store = "truststore"

    # This password is used for decrypting the trust store
    trust-store-password = "changeme"

    # Protocol to use for SSL encryption, choose from:
    # Java 6 & 7:
    # 'SSLv3', 'TLSv1'
    # Java 7:
    # 'TLSv1.1', 'TLSv1.2'
    protocol = "TLSv1"

    # Example: ["TLS_RSA_WITH_AES_128_CBC_SHA", "TLS_RSA_WITH_AES_256_CBC_SHA"]
    # You need to install the JCE Unlimited Strength Jurisdiction Policy
    # Files to use AES 256.
    # More info here:
    # http://docs.oracle.com/javase/7/docs/technotes/guides/security/SunProviders.html#SunJCEProvider
    enabled-algorithms = ["TLS_RSA_WITH_AES_128_CBC_SHA"]

    # There are three options, in increasing order of security:
    # "" or SecureRandom => (default)
    # "SHA1PRNG" => Can be slow because of blocking issues on Linux
    # "AES128CounterSecureRNG" => fastest startup and based on AES encryption
    # algorithm
    # "AES256CounterSecureRNG"
    # The following use one of 3 possible seed sources, depending on
    # availability: /dev/random, random.org and SecureRandom (provided by Java)
    # "AES128CounterInetRNG"
    # "AES256CounterInetRNG" (Install JCE Unlimited Strength Jurisdiction
    # Policy Files first)
    # Setting a value here may require you to supply the appropriate cipher
    # suite (see enabled-algorithms section above)
    random-number-generator = ""
    }
    }

    }

    }

